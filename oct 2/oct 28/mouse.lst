   1               		.file	"mouse.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Init
  12               	USART_Init:
  13               	.LFB11:
  14               		.file 1 "mouse.c"
   1:mouse.c       **** 
   2:mouse.c       **** 
   3:mouse.c       **** #define F_CPU 8000000UL			/* Define frequency here its 8MHz */
   4:mouse.c       **** #include <avr/io.h>
   5:mouse.c       **** #include <util/delay.h>
   6:mouse.c       **** #include <stdlib.h>
   7:mouse.c       **** #include <stdio.h>
   8:mouse.c       **** #include <avr/interrupt.h>
   9:mouse.c       **** 
  10:mouse.c       **** 
  11:mouse.c       **** 
  12:mouse.c       **** 
  13:mouse.c       **** //#define USART_BAUDRATE 9600
  14:mouse.c       **** #define BAUD_PRESCALE (((F_CPU / (USART_BAUDRATE * 16UL))) - 1)
  15:mouse.c       **** double oldX=0;
  16:mouse.c       **** double oldY=0;
  17:mouse.c       **** 
  18:mouse.c       **** void USART_Init(long USART_BAUDRATE)
  19:mouse.c       **** {
  15               		.loc 1 19 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  20:mouse.c       **** 	UCSRB |= (1 << RXEN) | (1 << TXEN);/* Turn on transmission and reception */
  22               		.loc 1 20 0
  23 0000 2AB1      		in r18,0xa
  24 0002 2861      		ori r18,lo8(24)
  25 0004 2AB9      		out 0xa,r18
  21:mouse.c       **** 	UCSRC |= (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1);/* Use 8-bit character sizes */
  26               		.loc 1 21 0
  27 0006 20B5      		in r18,0x20
  28 0008 2668      		ori r18,lo8(-122)
  29 000a 20BD      		out 0x20,r18
  22:mouse.c       **** 	UBRRL = BAUD_PRESCALE;		/* Load lower 8-bits of the baud rate value */
  30               		.loc 1 22 0
  31 000c 9B01      		movw r18,r22
  32 000e AC01      		movw r20,r24
  33 0010 84E0      		ldi r24,4
  34               		1:
  35 0012 220F      		lsl r18
  36 0014 331F      		rol r19
  37 0016 441F      		rol r20
  38 0018 551F      		rol r21
  39 001a 8A95      		dec r24
  40 001c 01F4      		brne 1b
  41 001e 60E0      		ldi r22,0
  42 0020 72E1      		ldi r23,lo8(18)
  43 0022 8AE7      		ldi r24,lo8(122)
  44 0024 90E0      		ldi r25,0
  45               	.LVL1:
  46 0026 0E94 0000 		call __udivmodsi4
  47 002a 8FEF      		ldi r24,lo8(-1)
  48 002c 820F      		add r24,r18
  49 002e 89B9      		out 0x9,r24
  23:mouse.c       **** 	UBRRH = (BAUD_PRESCALE >> 8);	/* Load upper 8-bits*/
  50               		.loc 1 23 0
  51 0030 DA01      		movw r26,r20
  52 0032 C901      		movw r24,r18
  53 0034 0197      		sbiw r24,1
  54 0036 A109      		sbc r26,__zero_reg__
  55 0038 B109      		sbc r27,__zero_reg__
  56 003a 892F      		mov r24,r25
  57 003c 9A2F      		mov r25,r26
  58 003e AB2F      		mov r26,r27
  59 0040 BB27      		clr r27
  60 0042 80BD      		out 0x20,r24
  61 0044 0895      		ret
  62               		.cfi_endproc
  63               	.LFE11:
  65               	.global	UART_RxChar
  67               	UART_RxChar:
  68               	.LFB12:
  24:mouse.c       **** }
  25:mouse.c       **** 
  26:mouse.c       **** unsigned char UART_RxChar()
  27:mouse.c       **** {
  69               		.loc 1 27 0
  70               		.cfi_startproc
  71               	/* prologue: function */
  72               	/* frame size = 0 */
  73               	/* stack size = 0 */
  74               	.L__stack_usage = 0
  75               	.L3:
  28:mouse.c       **** 	while ((UCSRA & (1 << RXC)) == 0);/* Wait till data is received */
  76               		.loc 1 28 0 discriminator 1
  77 0046 5F9B      		sbis 0xb,7
  78 0048 00C0      		rjmp .L3
  29:mouse.c       **** 	return(UDR);			/* Return the byte*/
  79               		.loc 1 29 0
  80 004a 8CB1      		in r24,0xc
  30:mouse.c       **** }
  81               		.loc 1 30 0
  82 004c 0895      		ret
  83               		.cfi_endproc
  84               	.LFE12:
  86               	.global	ADC_Init
  88               	ADC_Init:
  89               	.LFB15:
  31:mouse.c       **** 
  32:mouse.c       **** void UART_TxChar(char ch)
  33:mouse.c       **** {
  34:mouse.c       **** 	while (! (UCSRA & (1<<UDRE)));	/* Wait for empty transmit buffer*/
  35:mouse.c       **** 	UDR = ch ;
  36:mouse.c       **** }
  37:mouse.c       **** 
  38:mouse.c       **** void UART_SendString(char *str)
  39:mouse.c       **** {
  40:mouse.c       **** 	unsigned char j=0;
  41:mouse.c       **** 	
  42:mouse.c       **** 	while (str[j]!=0)		/* Send string till null */
  43:mouse.c       **** 	{
  44:mouse.c       **** 		UART_TxChar(str[j]);	
  45:mouse.c       **** 		j++;
  46:mouse.c       **** 	}
  47:mouse.c       **** }
  48:mouse.c       **** 
  49:mouse.c       **** void ADC_Init() {
  90               		.loc 1 49 0
  91               		.cfi_startproc
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  94               	/* stack size = 0 */
  95               	.L__stack_usage = 0
  50:mouse.c       ****     DDRA = 0x00;
  96               		.loc 1 50 0
  97 004e 1ABA      		out 0x1a,__zero_reg__
  51:mouse.c       **** 	ADCSRA |= (1 << ADEN); //Enable ADC (bit 7 = 1) enable ADC
  98               		.loc 1 51 0
  99 0050 379A      		sbi 0x6,7
  52:mouse.c       ****     ADCSRA |= (1 << ADPS1) | (1 << ADPS0); //Set prescaller to 128 (bits 2:0 = 111)
 100               		.loc 1 52 0
 101 0052 86B1      		in r24,0x6
 102 0054 8360      		ori r24,lo8(3)
 103 0056 86B9      		out 0x6,r24
  53:mouse.c       ****     ADMUX |= (1<<REFS0); //Selecting internal reference voltage
 104               		.loc 1 53 0
 105 0058 3E9A      		sbi 0x7,6
 106 005a 0895      		ret
 107               		.cfi_endproc
 108               	.LFE15:
 110               	.global	ADC_Read
 112               	ADC_Read:
 113               	.LFB16:
  54:mouse.c       ****     
  55:mouse.c       **** }
  56:mouse.c       **** 
  57:mouse.c       **** int ADC_Read(unsigned char channel) {
 114               		.loc 1 57 0
 115               		.cfi_startproc
 116               	.LVL2:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
  58:mouse.c       ****     ADMUX = (ADMUX & ~0b00001111) | (channel & 0b00001111); //Copy channel bits to 3:0 position
 121               		.loc 1 58 0
 122 005c 97B1      		in r25,0x7
 123 005e 907F      		andi r25,lo8(-16)
 124 0060 8F70      		andi r24,lo8(15)
 125               	.LVL3:
 126 0062 892B      		or r24,r25
 127 0064 87B9      		out 0x7,r24
  59:mouse.c       **** 	//ADMUX = 1<< REFS0 | (channel & (1<< MUX0 | 1<< MUX1 | 1<< MUX2 | 1<< MUX3 | 1<< MUX4));//select 
  60:mouse.c       **** 	//ADCSRA |= (1 << ADEN); //Enable ADC (bit 7 = 1)
  61:mouse.c       **** 
  62:mouse.c       ****     ADCSRA |= (1 << ADSC); //Start taking reading (bit 6 = 1)
 128               		.loc 1 62 0
 129 0066 369A      		sbi 0x6,6
 130               	.L8:
  63:mouse.c       ****     while(((ADCSRA>>ADSC) & 1) == 1) {} //Wait until bit 6 = 0
 131               		.loc 1 63 0 discriminator 1
 132 0068 3699      		sbic 0x6,6
 133 006a 00C0      		rjmp .L8
  64:mouse.c       **** 
  65:mouse.c       ****     return ADC;
 134               		.loc 1 65 0
 135 006c 84B1      		in r24,0x4
 136 006e 95B1      		in r25,0x4+1
  66:mouse.c       **** }
 137               		.loc 1 66 0
 138 0070 0895      		ret
 139               		.cfi_endproc
 140               	.LFE16:
 142               	.global	send_uart
 144               	send_uart:
 145               	.LFB19:
  67:mouse.c       **** 
  68:mouse.c       **** void SendSerialLong(int64_t value) {
  69:mouse.c       ****     char buffer[20];  // Adjust buffer size as needed
  70:mouse.c       ****     snprintf(buffer, sizeof(buffer), "%lld", value);  // Convert long to string
  71:mouse.c       **** 
  72:mouse.c       ****     // Assuming you have a UART_SendString function:
  73:mouse.c       ****     UART_SendString(buffer);  // Send the formatted string
  74:mouse.c       **** }
  75:mouse.c       **** void SendSerialDouble(double value)
  76:mouse.c       **** {
  77:mouse.c       **** 	char buffer[10];
  78:mouse.c       **** 	dtostrf(value,4,0,buffer);
  79:mouse.c       **** 	//USART_SendString(str);							/* Send Name string */
  80:mouse.c       **** 	UART_SendString(buffer);						/* Send value */
  81:mouse.c       **** 	//USART_TxChar(unit);								/* Send unit char */
  82:mouse.c       **** 	//USART_TxChar('\t');								/* Send tab char */
  83:mouse.c       **** 	_delay_ms(10);
  84:mouse.c       **** }
  85:mouse.c       **** 
  86:mouse.c       **** void send_uart(unsigned char val){
 146               		.loc 1 86 0
 147               		.cfi_startproc
 148               	/* prologue: function */
 149               	/* frame size = 0 */
 150               	/* stack size = 0 */
 151               	.L__stack_usage = 0
 152               	.LVL4:
 153               	.L11:
  87:mouse.c       **** 	while ((UCSRA & (1 << UDRE)) == 0) ; 	//wait until previous transmition is finished
 154               		.loc 1 87 0 discriminator 1
 155 0072 5D9B      		sbis 0xb,5
 156 0074 00C0      		rjmp .L11
  88:mouse.c       **** 	UDR = val;								//Transmit the charater
 157               		.loc 1 88 0
 158 0076 8CB9      		out 0xc,r24
 159 0078 0895      		ret
 160               		.cfi_endproc
 161               	.LFE19:
 163               	.global	UART_SendString
 165               	UART_SendString:
 166               	.LFB14:
  39:mouse.c       **** 	unsigned char j=0;
 167               		.loc 1 39 0
 168               		.cfi_startproc
 169               	.LVL5:
 170 007a 0F93      		push r16
 171               	.LCFI0:
 172               		.cfi_def_cfa_offset 3
 173               		.cfi_offset 16, -2
 174 007c 1F93      		push r17
 175               	.LCFI1:
 176               		.cfi_def_cfa_offset 4
 177               		.cfi_offset 17, -3
 178 007e CF93      		push r28
 179               	.LCFI2:
 180               		.cfi_def_cfa_offset 5
 181               		.cfi_offset 28, -4
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 3 */
 185               	.L__stack_usage = 3
 186 0080 8C01      		movw r16,r24
 187               	.LVL6:
  40:mouse.c       **** 	
 188               		.loc 1 40 0
 189 0082 C0E0      		ldi r28,0
 190               	.LVL7:
 191               	.L15:
  42:mouse.c       **** 	{
 192               		.loc 1 42 0
 193 0084 F801      		movw r30,r16
 194 0086 EC0F      		add r30,r28
 195 0088 F11D      		adc r31,__zero_reg__
 196 008a 8081      		ld r24,Z
 197 008c 8823      		tst r24
 198 008e 01F0      		breq .L17
  44:mouse.c       **** 		j++;
 199               		.loc 1 44 0
 200 0090 0E94 0000 		call send_uart
 201               	.LVL8:
  45:mouse.c       **** 	}
 202               		.loc 1 45 0
 203 0094 CF5F      		subi r28,lo8(-(1))
 204               	.LVL9:
 205 0096 00C0      		rjmp .L15
 206               	.L17:
 207               	/* epilogue start */
  47:mouse.c       **** 
 208               		.loc 1 47 0
 209 0098 CF91      		pop r28
 210               	.LVL10:
 211 009a 1F91      		pop r17
 212 009c 0F91      		pop r16
 213               	.LVL11:
 214 009e 0895      		ret
 215               		.cfi_endproc
 216               	.LFE14:
 218               		.section	.rodata.str1.1,"aMS",@progbits,1
 219               	.LC0:
 220 0000 256C 6C64 		.string	"%lld"
 220      00
 221               		.text
 222               	.global	SendSerialLong
 224               	SendSerialLong:
 225               	.LFB17:
  68:mouse.c       ****     char buffer[20];  // Adjust buffer size as needed
 226               		.loc 1 68 0
 227               		.cfi_startproc
 228               	.LVL12:
 229 00a0 0F93      		push r16
 230               	.LCFI3:
 231               		.cfi_def_cfa_offset 3
 232               		.cfi_offset 16, -2
 233 00a2 1F93      		push r17
 234               	.LCFI4:
 235               		.cfi_def_cfa_offset 4
 236               		.cfi_offset 17, -3
 237 00a4 CF93      		push r28
 238               	.LCFI5:
 239               		.cfi_def_cfa_offset 5
 240               		.cfi_offset 28, -4
 241 00a6 DF93      		push r29
 242               	.LCFI6:
 243               		.cfi_def_cfa_offset 6
 244               		.cfi_offset 29, -5
 245 00a8 CDB7      		in r28,__SP_L__
 246 00aa DEB7      		in r29,__SP_H__
 247               	.LCFI7:
 248               		.cfi_def_cfa_register 28
 249 00ac 6497      		sbiw r28,20
 250               	.LCFI8:
 251               		.cfi_def_cfa_offset 26
 252 00ae 0FB6      		in __tmp_reg__,__SREG__
 253 00b0 F894      		cli
 254 00b2 DEBF      		out __SP_H__,r29
 255 00b4 0FBE      		out __SREG__,__tmp_reg__
 256 00b6 CDBF      		out __SP_L__,r28
 257               	/* prologue: function */
 258               	/* frame size = 20 */
 259               	/* stack size = 24 */
 260               	.L__stack_usage = 24
  70:mouse.c       **** 
 261               		.loc 1 70 0
 262 00b8 9F93      		push r25
 263 00ba 8F93      		push r24
 264 00bc 7F93      		push r23
 265 00be 6F93      		push r22
 266 00c0 5F93      		push r21
 267 00c2 4F93      		push r20
 268 00c4 3F93      		push r19
 269 00c6 2F93      		push r18
 270 00c8 80E0      		ldi r24,lo8(.LC0)
 271 00ca 90E0      		ldi r25,hi8(.LC0)
 272 00cc 9F93      		push r25
 273 00ce 8F93      		push r24
 274 00d0 1F92      		push __zero_reg__
 275 00d2 84E1      		ldi r24,lo8(20)
 276 00d4 8F93      		push r24
 277 00d6 8E01      		movw r16,r28
 278 00d8 0F5F      		subi r16,-1
 279 00da 1F4F      		sbci r17,-1
 280 00dc 1F93      		push r17
 281 00de 0F93      		push r16
 282 00e0 0E94 0000 		call snprintf
 283               	.LVL13:
  73:mouse.c       **** }
 284               		.loc 1 73 0
 285 00e4 C801      		movw r24,r16
 286 00e6 0E94 0000 		call UART_SendString
 287               	.LVL14:
  74:mouse.c       **** void SendSerialDouble(double value)
 288               		.loc 1 74 0
 289 00ea 0FB6      		in __tmp_reg__,__SREG__
 290 00ec F894      		cli
 291 00ee DEBF      		out __SP_H__,r29
 292 00f0 0FBE      		out __SREG__,__tmp_reg__
 293 00f2 CDBF      		out __SP_L__,r28
 294               	/* epilogue start */
 295 00f4 6496      		adiw r28,20
 296 00f6 0FB6      		in __tmp_reg__,__SREG__
 297 00f8 F894      		cli
 298 00fa DEBF      		out __SP_H__,r29
 299 00fc 0FBE      		out __SREG__,__tmp_reg__
 300 00fe CDBF      		out __SP_L__,r28
 301 0100 DF91      		pop r29
 302 0102 CF91      		pop r28
 303 0104 1F91      		pop r17
 304 0106 0F91      		pop r16
 305 0108 0895      		ret
 306               		.cfi_endproc
 307               	.LFE17:
 309               	.global	SendSerialDouble
 311               	SendSerialDouble:
 312               	.LFB18:
  76:mouse.c       **** 	char buffer[10];
 313               		.loc 1 76 0
 314               		.cfi_startproc
 315               	.LVL15:
 316 010a 0F93      		push r16
 317               	.LCFI9:
 318               		.cfi_def_cfa_offset 3
 319               		.cfi_offset 16, -2
 320 010c 1F93      		push r17
 321               	.LCFI10:
 322               		.cfi_def_cfa_offset 4
 323               		.cfi_offset 17, -3
 324 010e CF93      		push r28
 325               	.LCFI11:
 326               		.cfi_def_cfa_offset 5
 327               		.cfi_offset 28, -4
 328 0110 DF93      		push r29
 329               	.LCFI12:
 330               		.cfi_def_cfa_offset 6
 331               		.cfi_offset 29, -5
 332 0112 CDB7      		in r28,__SP_L__
 333 0114 DEB7      		in r29,__SP_H__
 334               	.LCFI13:
 335               		.cfi_def_cfa_register 28
 336 0116 2A97      		sbiw r28,10
 337               	.LCFI14:
 338               		.cfi_def_cfa_offset 16
 339 0118 0FB6      		in __tmp_reg__,__SREG__
 340 011a F894      		cli
 341 011c DEBF      		out __SP_H__,r29
 342 011e 0FBE      		out __SREG__,__tmp_reg__
 343 0120 CDBF      		out __SP_L__,r28
 344               	/* prologue: function */
 345               	/* frame size = 10 */
 346               	/* stack size = 14 */
 347               	.L__stack_usage = 14
  78:mouse.c       **** 	//USART_SendString(str);							/* Send Name string */
 348               		.loc 1 78 0
 349 0122 8E01      		movw r16,r28
 350 0124 0F5F      		subi r16,-1
 351 0126 1F4F      		sbci r17,-1
 352 0128 20E0      		ldi r18,0
 353 012a 44E0      		ldi r20,lo8(4)
 354 012c 0E94 0000 		call dtostrf
 355               	.LVL16:
  80:mouse.c       **** 	//USART_TxChar(unit);								/* Send unit char */
 356               		.loc 1 80 0
 357 0130 C801      		movw r24,r16
 358 0132 0E94 0000 		call UART_SendString
 359               	.LVL17:
 360               	.LBB13:
 361               	.LBB14:
 362               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 363               		.loc 2 187 0
 364 0136 8FE1      		ldi r24,lo8(19999)
 365 0138 9EE4      		ldi r25,hi8(19999)
 366 013a 0197      	1:	sbiw r24,1
 367 013c 01F4      		brne 1b
 368 013e 00C0      		rjmp .
 369 0140 0000      		nop
 370               	.LVL18:
 371               	/* epilogue start */
 372               	.LBE14:
 373               	.LBE13:
  84:mouse.c       **** 
 374               		.loc 1 84 0
 375 0142 2A96      		adiw r28,10
 376 0144 0FB6      		in __tmp_reg__,__SREG__
 377 0146 F894      		cli
 378 0148 DEBF      		out __SP_H__,r29
 379 014a 0FBE      		out __SREG__,__tmp_reg__
 380 014c CDBF      		out __SP_L__,r28
 381 014e DF91      		pop r29
 382 0150 CF91      		pop r28
 383 0152 1F91      		pop r17
 384 0154 0F91      		pop r16
 385 0156 0895      		ret
 386               		.cfi_endproc
 387               	.LFE18:
 389               	.global	UART_TxChar
 391               	UART_TxChar:
 392               	.LFB27:
 393               		.cfi_startproc
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 396               	/* stack size = 0 */
 397               	.L__stack_usage = 0
 398 0158 0C94 0000 		jmp send_uart
 399               		.cfi_endproc
 400               	.LFE27:
 402               	.global	initTimer0CTC
 404               	initTimer0CTC:
 405               	.LFB20:
  89:mouse.c       **** }
  90:mouse.c       **** 
  91:mouse.c       **** 
  92:mouse.c       **** 
  93:mouse.c       **** //FUNCTION to setup TCCR(Timer/Counter Control Register)
  94:mouse.c       **** void initTimer0CTC(void){ //CTC mode; clock: ps/8 OC0 disconnected
 406               		.loc 1 94 0
 407               		.cfi_startproc
 408               	/* prologue: function */
 409               	/* frame size = 0 */
 410               	/* stack size = 0 */
 411               	.L__stack_usage = 0
  95:mouse.c       ****     TCCR0 |= 1<<CS01 | 1<<WGM01; //WGM01 = 1 - CTC(Clear Timer on Compare Match) mode enabled so OC
 412               		.loc 1 95 0
 413 015c 83B7      		in r24,0x33
 414 015e 8A60      		ori r24,lo8(10)
 415 0160 83BF      		out 0x33,r24
  96:mouse.c       ****     TIMSK |= 1<<OCIE0; //TIMSK = Timer Counter Interrupt Mask Register; OCI0 = Timer/Counter0 Outpu
 416               		.loc 1 96 0
 417 0162 89B7      		in r24,0x39
 418 0164 8260      		ori r24,lo8(2)
 419 0166 89BF      		out 0x39,r24
  97:mouse.c       ****     OCR0=249; //Output Compare Register max value
 420               		.loc 1 97 0
 421 0168 89EF      		ldi r24,lo8(-7)
 422 016a 8CBF      		out 0x3c,r24
 423 016c 0895      		ret
 424               		.cfi_endproc
 425               	.LFE20:
 427               		.section	.rodata.str1.1
 428               	.LC1:
 429 0005 7374 6174 		.string	"stat"
 429      00
 430               		.text
 431               	.global	__vector_1
 433               	__vector_1:
 434               	.LFB21:
  98:mouse.c       **** }
  99:mouse.c       **** 
 100:mouse.c       **** 
 101:mouse.c       **** //Interrupt Service Routing for External interrupt 0 ; START the clock INT0 = PD2
 102:mouse.c       **** ISR(INT0_vect){
 435               		.loc 1 102 0
 436               		.cfi_startproc
 437 016e 1F92      		push r1
 438               	.LCFI15:
 439               		.cfi_def_cfa_offset 3
 440               		.cfi_offset 1, -2
 441 0170 0F92      		push r0
 442               	.LCFI16:
 443               		.cfi_def_cfa_offset 4
 444               		.cfi_offset 0, -3
 445 0172 0FB6      		in r0,__SREG__
 446 0174 0F92      		push r0
 447 0176 1124      		clr __zero_reg__
 448 0178 2F93      		push r18
 449               	.LCFI17:
 450               		.cfi_def_cfa_offset 5
 451               		.cfi_offset 18, -4
 452 017a 3F93      		push r19
 453               	.LCFI18:
 454               		.cfi_def_cfa_offset 6
 455               		.cfi_offset 19, -5
 456 017c 4F93      		push r20
 457               	.LCFI19:
 458               		.cfi_def_cfa_offset 7
 459               		.cfi_offset 20, -6
 460 017e 5F93      		push r21
 461               	.LCFI20:
 462               		.cfi_def_cfa_offset 8
 463               		.cfi_offset 21, -7
 464 0180 6F93      		push r22
 465               	.LCFI21:
 466               		.cfi_def_cfa_offset 9
 467               		.cfi_offset 22, -8
 468 0182 7F93      		push r23
 469               	.LCFI22:
 470               		.cfi_def_cfa_offset 10
 471               		.cfi_offset 23, -9
 472 0184 8F93      		push r24
 473               	.LCFI23:
 474               		.cfi_def_cfa_offset 11
 475               		.cfi_offset 24, -10
 476 0186 9F93      		push r25
 477               	.LCFI24:
 478               		.cfi_def_cfa_offset 12
 479               		.cfi_offset 25, -11
 480 0188 AF93      		push r26
 481               	.LCFI25:
 482               		.cfi_def_cfa_offset 13
 483               		.cfi_offset 26, -12
 484 018a BF93      		push r27
 485               	.LCFI26:
 486               		.cfi_def_cfa_offset 14
 487               		.cfi_offset 27, -13
 488 018c EF93      		push r30
 489               	.LCFI27:
 490               		.cfi_def_cfa_offset 15
 491               		.cfi_offset 30, -14
 492 018e FF93      		push r31
 493               	.LCFI28:
 494               		.cfi_def_cfa_offset 16
 495               		.cfi_offset 31, -15
 496               	/* prologue: Signal */
 497               	/* frame size = 0 */
 498               	/* stack size = 15 */
 499               	.L__stack_usage = 15
 103:mouse.c       **** 	
 104:mouse.c       **** // this function is called when INT0 bit (PD2) is interrupted.
 105:mouse.c       **** 
 106:mouse.c       **** // You can also use INTERRUPT() function instead.
 107:mouse.c       **** 
 108:mouse.c       **** // SIG_INTERRUPT0 -> INT0 (PD2)
 109:mouse.c       **** 
 110:mouse.c       **** // SIG_INTERRUPT1 -> INT1 (PD3)
 111:mouse.c       **** 
 112:mouse.c       **** // While Button is pressed, LED is on
 113:mouse.c       **** UART_SendString("stat");
 500               		.loc 1 113 0
 501 0190 80E0      		ldi r24,lo8(.LC1)
 502 0192 90E0      		ldi r25,hi8(.LC1)
 503 0194 0E94 0000 		call UART_SendString
 504               	.LVL19:
 505               	.LBB15:
 506               	.LBB16:
 507               		.loc 2 187 0
 508 0198 2FEF      		ldi r18,lo8(479999)
 509 019a 82E5      		ldi r24,hi8(479999)
 510 019c 97E0      		ldi r25,hlo8(479999)
 511 019e 2150      	1:	subi r18,1
 512 01a0 8040      		sbci r24,0
 513 01a2 9040      		sbci r25,0
 514 01a4 01F4      		brne 1b
 515 01a6 00C0      		rjmp .
 516 01a8 0000      		nop
 517               	.LVL20:
 518               	/* epilogue start */
 519               	.LBE16:
 520               	.LBE15:
 114:mouse.c       **** _delay_ms(300);
 115:mouse.c       **** 
 116:mouse.c       **** }
 521               		.loc 1 116 0
 522 01aa FF91      		pop r31
 523 01ac EF91      		pop r30
 524 01ae BF91      		pop r27
 525 01b0 AF91      		pop r26
 526 01b2 9F91      		pop r25
 527 01b4 8F91      		pop r24
 528 01b6 7F91      		pop r23
 529 01b8 6F91      		pop r22
 530 01ba 5F91      		pop r21
 531 01bc 4F91      		pop r20
 532 01be 3F91      		pop r19
 533 01c0 2F91      		pop r18
 534 01c2 0F90      		pop r0
 535 01c4 0FBE      		out __SREG__,r0
 536 01c6 0F90      		pop r0
 537 01c8 1F90      		pop r1
 538 01ca 1895      		reti
 539               		.cfi_endproc
 540               	.LFE21:
 542               		.section	.rodata.str1.1
 543               	.LC2:
 544 000a 7269 6768 		.string	"righ"
 544      00
 545               		.text
 546               	.global	__vector_2
 548               	__vector_2:
 549               	.LFB22:
 117:mouse.c       **** ISR(INT1_vect){
 550               		.loc 1 117 0
 551               		.cfi_startproc
 552 01cc 1F92      		push r1
 553               	.LCFI29:
 554               		.cfi_def_cfa_offset 3
 555               		.cfi_offset 1, -2
 556 01ce 0F92      		push r0
 557               	.LCFI30:
 558               		.cfi_def_cfa_offset 4
 559               		.cfi_offset 0, -3
 560 01d0 0FB6      		in r0,__SREG__
 561 01d2 0F92      		push r0
 562 01d4 1124      		clr __zero_reg__
 563 01d6 2F93      		push r18
 564               	.LCFI31:
 565               		.cfi_def_cfa_offset 5
 566               		.cfi_offset 18, -4
 567 01d8 3F93      		push r19
 568               	.LCFI32:
 569               		.cfi_def_cfa_offset 6
 570               		.cfi_offset 19, -5
 571 01da 4F93      		push r20
 572               	.LCFI33:
 573               		.cfi_def_cfa_offset 7
 574               		.cfi_offset 20, -6
 575 01dc 5F93      		push r21
 576               	.LCFI34:
 577               		.cfi_def_cfa_offset 8
 578               		.cfi_offset 21, -7
 579 01de 6F93      		push r22
 580               	.LCFI35:
 581               		.cfi_def_cfa_offset 9
 582               		.cfi_offset 22, -8
 583 01e0 7F93      		push r23
 584               	.LCFI36:
 585               		.cfi_def_cfa_offset 10
 586               		.cfi_offset 23, -9
 587 01e2 8F93      		push r24
 588               	.LCFI37:
 589               		.cfi_def_cfa_offset 11
 590               		.cfi_offset 24, -10
 591 01e4 9F93      		push r25
 592               	.LCFI38:
 593               		.cfi_def_cfa_offset 12
 594               		.cfi_offset 25, -11
 595 01e6 AF93      		push r26
 596               	.LCFI39:
 597               		.cfi_def_cfa_offset 13
 598               		.cfi_offset 26, -12
 599 01e8 BF93      		push r27
 600               	.LCFI40:
 601               		.cfi_def_cfa_offset 14
 602               		.cfi_offset 27, -13
 603 01ea EF93      		push r30
 604               	.LCFI41:
 605               		.cfi_def_cfa_offset 15
 606               		.cfi_offset 30, -14
 607 01ec FF93      		push r31
 608               	.LCFI42:
 609               		.cfi_def_cfa_offset 16
 610               		.cfi_offset 31, -15
 611               	/* prologue: Signal */
 612               	/* frame size = 0 */
 613               	/* stack size = 15 */
 614               	.L__stack_usage = 15
 118:mouse.c       **** 	
 119:mouse.c       **** // this function is called when INT0 bit (PD2) is interrupted.
 120:mouse.c       **** 
 121:mouse.c       **** // You can also use INTERRUPT() function instead.
 122:mouse.c       **** 
 123:mouse.c       **** // SIG_INTERRUPT0 -> INT0 (PD2)
 124:mouse.c       **** 
 125:mouse.c       **** // SIG_INTERRUPT1 -> INT1 (PD3)
 126:mouse.c       **** 
 127:mouse.c       **** // While Button is pressed, LED is on
 128:mouse.c       **** UART_SendString("righ");
 615               		.loc 1 128 0
 616 01ee 80E0      		ldi r24,lo8(.LC2)
 617 01f0 90E0      		ldi r25,hi8(.LC2)
 618 01f2 0E94 0000 		call UART_SendString
 619               	.LVL21:
 620               	.LBB17:
 621               	.LBB18:
 622               		.loc 2 187 0
 623 01f6 2FEF      		ldi r18,lo8(959999)
 624 01f8 85EA      		ldi r24,hi8(959999)
 625 01fa 9EE0      		ldi r25,hlo8(959999)
 626 01fc 2150      	1:	subi r18,1
 627 01fe 8040      		sbci r24,0
 628 0200 9040      		sbci r25,0
 629 0202 01F4      		brne 1b
 630 0204 00C0      		rjmp .
 631 0206 0000      		nop
 632               	.LVL22:
 633               	/* epilogue start */
 634               	.LBE18:
 635               	.LBE17:
 129:mouse.c       **** _delay_ms(600);
 130:mouse.c       **** 
 131:mouse.c       **** }
 636               		.loc 1 131 0
 637 0208 FF91      		pop r31
 638 020a EF91      		pop r30
 639 020c BF91      		pop r27
 640 020e AF91      		pop r26
 641 0210 9F91      		pop r25
 642 0212 8F91      		pop r24
 643 0214 7F91      		pop r23
 644 0216 6F91      		pop r22
 645 0218 5F91      		pop r21
 646 021a 4F91      		pop r20
 647 021c 3F91      		pop r19
 648 021e 2F91      		pop r18
 649 0220 0F90      		pop r0
 650 0222 0FBE      		out __SREG__,r0
 651 0224 0F90      		pop r0
 652 0226 1F90      		pop r1
 653 0228 1895      		reti
 654               		.cfi_endproc
 655               	.LFE22:
 657               		.section	.rodata.str1.1
 658               	.LC3:
 659 000f 6C65 6674 		.string	"left"
 659      00
 660               		.text
 661               	.global	__vector_3
 663               	__vector_3:
 664               	.LFB23:
 132:mouse.c       **** ISR(INT2_vect){
 665               		.loc 1 132 0
 666               		.cfi_startproc
 667 022a 1F92      		push r1
 668               	.LCFI43:
 669               		.cfi_def_cfa_offset 3
 670               		.cfi_offset 1, -2
 671 022c 0F92      		push r0
 672               	.LCFI44:
 673               		.cfi_def_cfa_offset 4
 674               		.cfi_offset 0, -3
 675 022e 0FB6      		in r0,__SREG__
 676 0230 0F92      		push r0
 677 0232 1124      		clr __zero_reg__
 678 0234 2F93      		push r18
 679               	.LCFI45:
 680               		.cfi_def_cfa_offset 5
 681               		.cfi_offset 18, -4
 682 0236 3F93      		push r19
 683               	.LCFI46:
 684               		.cfi_def_cfa_offset 6
 685               		.cfi_offset 19, -5
 686 0238 4F93      		push r20
 687               	.LCFI47:
 688               		.cfi_def_cfa_offset 7
 689               		.cfi_offset 20, -6
 690 023a 5F93      		push r21
 691               	.LCFI48:
 692               		.cfi_def_cfa_offset 8
 693               		.cfi_offset 21, -7
 694 023c 6F93      		push r22
 695               	.LCFI49:
 696               		.cfi_def_cfa_offset 9
 697               		.cfi_offset 22, -8
 698 023e 7F93      		push r23
 699               	.LCFI50:
 700               		.cfi_def_cfa_offset 10
 701               		.cfi_offset 23, -9
 702 0240 8F93      		push r24
 703               	.LCFI51:
 704               		.cfi_def_cfa_offset 11
 705               		.cfi_offset 24, -10
 706 0242 9F93      		push r25
 707               	.LCFI52:
 708               		.cfi_def_cfa_offset 12
 709               		.cfi_offset 25, -11
 710 0244 AF93      		push r26
 711               	.LCFI53:
 712               		.cfi_def_cfa_offset 13
 713               		.cfi_offset 26, -12
 714 0246 BF93      		push r27
 715               	.LCFI54:
 716               		.cfi_def_cfa_offset 14
 717               		.cfi_offset 27, -13
 718 0248 EF93      		push r30
 719               	.LCFI55:
 720               		.cfi_def_cfa_offset 15
 721               		.cfi_offset 30, -14
 722 024a FF93      		push r31
 723               	.LCFI56:
 724               		.cfi_def_cfa_offset 16
 725               		.cfi_offset 31, -15
 726               	/* prologue: Signal */
 727               	/* frame size = 0 */
 728               	/* stack size = 15 */
 729               	.L__stack_usage = 15
 133:mouse.c       **** 	
 134:mouse.c       **** // this function is called when INT0 bit (PD2) is interrupted.
 135:mouse.c       **** 
 136:mouse.c       **** // You can also use INTERRUPT() function instead.
 137:mouse.c       **** 
 138:mouse.c       **** // SIG_INTERRUPT0 -> INT0 (PD2)
 139:mouse.c       **** 
 140:mouse.c       **** // SIG_INTERRUPT1 -> INT1 (PD3)
 141:mouse.c       **** 
 142:mouse.c       **** // While Button is pressed, LED is on
 143:mouse.c       **** UART_SendString("left");
 730               		.loc 1 143 0
 731 024c 80E0      		ldi r24,lo8(.LC3)
 732 024e 90E0      		ldi r25,hi8(.LC3)
 733 0250 0E94 0000 		call UART_SendString
 734               	.LVL23:
 735               	.LBB19:
 736               	.LBB20:
 737               		.loc 2 187 0
 738 0254 2FEF      		ldi r18,lo8(479999)
 739 0256 82E5      		ldi r24,hi8(479999)
 740 0258 97E0      		ldi r25,hlo8(479999)
 741 025a 2150      	1:	subi r18,1
 742 025c 8040      		sbci r24,0
 743 025e 9040      		sbci r25,0
 744 0260 01F4      		brne 1b
 745 0262 00C0      		rjmp .
 746 0264 0000      		nop
 747               	.LVL24:
 748               	/* epilogue start */
 749               	.LBE20:
 750               	.LBE19:
 144:mouse.c       **** _delay_ms(300);
 145:mouse.c       **** 
 146:mouse.c       **** }
 751               		.loc 1 146 0
 752 0266 FF91      		pop r31
 753 0268 EF91      		pop r30
 754 026a BF91      		pop r27
 755 026c AF91      		pop r26
 756 026e 9F91      		pop r25
 757 0270 8F91      		pop r24
 758 0272 7F91      		pop r23
 759 0274 6F91      		pop r22
 760 0276 5F91      		pop r21
 761 0278 4F91      		pop r20
 762 027a 3F91      		pop r19
 763 027c 2F91      		pop r18
 764 027e 0F90      		pop r0
 765 0280 0FBE      		out __SREG__,r0
 766 0282 0F90      		pop r0
 767 0284 1F90      		pop r1
 768 0286 1895      		reti
 769               		.cfi_endproc
 770               	.LFE23:
 772               	.global	externalInt
 774               	externalInt:
 775               	.LFB24:
 147:mouse.c       **** 
 148:mouse.c       **** void externalInt(void) {
 776               		.loc 1 148 0
 777               		.cfi_startproc
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 0 */
 781               	.L__stack_usage = 0
 149:mouse.c       ****     DDRD &= ~(1 << PD3); // Setting up DDRD PIN3 as input
 782               		.loc 1 149 0
 783 0288 8B98      		cbi 0x11,3
 150:mouse.c       ****     DDRD &= ~(1 << PD2); // Setting up DDRD PIN2 as input
 784               		.loc 1 150 0
 785 028a 8A98      		cbi 0x11,2
 151:mouse.c       ****     DDRB &= ~(1 << PB2); // Setting up DDRB PIN2 (PB2) as input for INT2
 786               		.loc 1 151 0
 787 028c BA98      		cbi 0x17,2
 152:mouse.c       **** 
 153:mouse.c       ****     GICR |= (1 << INT1) | (1 << INT0) | (1 << INT2); // Enable external interrupt 0, 1, and 2
 788               		.loc 1 153 0
 789 028e 8BB7      		in r24,0x3b
 790 0290 806E      		ori r24,lo8(-32)
 791 0292 8BBF      		out 0x3b,r24
 154:mouse.c       ****     MCUCR |= (1 << ISC01) | (1 << ISC10) | (1 << ISC11); // Set ISC10 bit to configure INT1 and INT
 792               		.loc 1 154 0
 793 0294 85B7      		in r24,0x35
 794 0296 8E60      		ori r24,lo8(14)
 795 0298 85BF      		out 0x35,r24
 796 029a 0895      		ret
 797               		.cfi_endproc
 798               	.LFE24:
 800               	.global	__floatsisf
 801               		.section	.text.startup,"ax",@progbits
 802               	.global	main
 804               	main:
 805               	.LFB25:
 155:mouse.c       **** 
 156:mouse.c       ****     // For INT2 (PB2), configure it for a falling or rising edge trigger (choose one):
 157:mouse.c       ****     // MCUCSR |= (1 << ISC2); // For rising edge trigger
 158:mouse.c       ****     // MCUCSR &= ~(1 << ISC2); // For falling edge trigger
 159:mouse.c       **** }
 160:mouse.c       **** 
 161:mouse.c       **** 
 162:mouse.c       **** 
 163:mouse.c       **** int main(void) {
 806               		.loc 1 163 0
 807               		.cfi_startproc
 808               	/* prologue: function */
 809               	/* frame size = 0 */
 810               	/* stack size = 0 */
 811               	.L__stack_usage = 0
 164:mouse.c       **** 
 165:mouse.c       **** 
 166:mouse.c       **** //////////////////////////////click
 167:mouse.c       **** 
 168:mouse.c       **** 	//DDRB = (1<<PB3);  // put PortB bit 5 as output
 169:mouse.c       **** 	initTimer0CTC(); //FUNCTION to setup TCCR(Timer/Counter Control Register)
 812               		.loc 1 169 0
 813 0000 0E94 0000 		call initTimer0CTC
 814               	.LVL25:
 170:mouse.c       **** 	sei(); // Enable Interrupts
 815               		.loc 1 170 0
 816               	/* #APP */
 817               	 ;  170 "mouse.c" 1
 818 0004 7894      		sei
 819               	 ;  0 "" 2
 171:mouse.c       **** 	externalInt();
 820               		.loc 1 171 0
 821               	/* #NOAPP */
 822 0006 0E94 0000 		call externalInt
 823               	.LVL26:
 172:mouse.c       **** //////////////////////////////////////////////////////
 173:mouse.c       **** 
 174:mouse.c       **** 
 175:mouse.c       **** 
 176:mouse.c       **** 
 177:mouse.c       ****    	char c;
 178:mouse.c       ****     	ADC_Init();
 824               		.loc 1 178 0
 825 000a 0E94 0000 		call ADC_Init
 826               	.LVL27:
 179:mouse.c       **** 	USART_Init(9600);					/* Initialize USART with 9600 Baud rate */
 827               		.loc 1 179 0
 828 000e 60E8      		ldi r22,lo8(-128)
 829 0010 75E2      		ldi r23,lo8(37)
 830 0012 80E0      		ldi r24,0
 831 0014 90E0      		ldi r25,0
 832 0016 0E94 0000 		call USART_Init
 833               	.LVL28:
 834               	.L27:
 835               	.LBB21:
 180:mouse.c       **** 	char buffer[50];
 181:mouse.c       ****     	while (1) {
 182:mouse.c       ****         	double adcX = ADC_Read(1); //get PA0
 836               		.loc 1 182 0 discriminator 1
 837 001a 81E0      		ldi r24,lo8(1)
 838 001c 0E94 0000 		call ADC_Read
 839               	.LVL29:
 183:mouse.c       **** 		SendSerialDouble(adcX);
 840               		.loc 1 183 0 discriminator 1
 841 0020 BC01      		movw r22,r24
 842 0022 990F      		lsl r25
 843 0024 880B      		sbc r24,r24
 844 0026 990B      		sbc r25,r25
 845 0028 0E94 0000 		call __floatsisf
 846               	.LVL30:
 847 002c 0E94 0000 		call SendSerialDouble
 848               	.LVL31:
 849               	.LBB22:
 850               	.LBB23:
 851               		.loc 2 187 0 discriminator 1
 852 0030 2FEF      		ldi r18,lo8(159999)
 853 0032 80E7      		ldi r24,hi8(159999)
 854 0034 92E0      		ldi r25,hlo8(159999)
 855 0036 2150      	1:	subi r18,1
 856 0038 8040      		sbci r24,0
 857 003a 9040      		sbci r25,0
 858 003c 01F4      		brne 1b
 859 003e 00C0      		rjmp .
 860 0040 0000      		nop
 861 0042 00C0      		rjmp .L27
 862               	.LBE23:
 863               	.LBE22:
 864               	.LBE21:
 865               		.cfi_endproc
 866               	.LFE25:
 868               	.global	oldY
 869               		.section .bss
 872               	oldY:
 873 0000 0000 0000 		.zero	4
 874               	.global	oldX
 877               	oldX:
 878 0004 0000 0000 		.zero	4
 879               		.text
 880               	.Letext0:
 881               		.file 3 "/usr/lib/avr/include/stdint.h"
 882               		.file 4 "/usr/lib/avr/include/stdio.h"
 883               		.file 5 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 mouse.c
     /tmp/cc3SSStx.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc3SSStx.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc3SSStx.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc3SSStx.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc3SSStx.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc3SSStx.s:12     .text:0000000000000000 USART_Init
     /tmp/cc3SSStx.s:67     .text:0000000000000046 UART_RxChar
     /tmp/cc3SSStx.s:88     .text:000000000000004e ADC_Init
     /tmp/cc3SSStx.s:112    .text:000000000000005c ADC_Read
     /tmp/cc3SSStx.s:144    .text:0000000000000072 send_uart
     /tmp/cc3SSStx.s:165    .text:000000000000007a UART_SendString
     /tmp/cc3SSStx.s:224    .text:00000000000000a0 SendSerialLong
     /tmp/cc3SSStx.s:311    .text:000000000000010a SendSerialDouble
     /tmp/cc3SSStx.s:391    .text:0000000000000158 UART_TxChar
     /tmp/cc3SSStx.s:404    .text:000000000000015c initTimer0CTC
     /tmp/cc3SSStx.s:433    .text:000000000000016e __vector_1
     /tmp/cc3SSStx.s:548    .text:00000000000001cc __vector_2
     /tmp/cc3SSStx.s:663    .text:000000000000022a __vector_3
     /tmp/cc3SSStx.s:774    .text:0000000000000288 externalInt
     /tmp/cc3SSStx.s:804    .text.startup:0000000000000000 main
     /tmp/cc3SSStx.s:872    .bss:0000000000000000 oldY
     /tmp/cc3SSStx.s:877    .bss:0000000000000004 oldX

UNDEFINED SYMBOLS
__udivmodsi4
snprintf
dtostrf
__floatsisf
__do_copy_data
__do_clear_bss
